# Derived Query Methods

In this lesson, we’ll explore Spring Data JPA’s derived query methods. We'll discuss the naming convention, which is the cornerstone of this feature.

The relevant module for this lesson is: [derived-query-methods-end](https://github.com/nbicocchi/spring-boot-course/tree/module5/derived-query-methods-end)

## Introduction

Derived queries are probably one of the most popular features of Spring Data JPA, since they significantly reduce the amount of boilerplate code that’s required at the data access layer.

Simply put, it’s a very straightforward way of **defining queries by declaring interface methods in our repositories following an intuitive naming convention**.

For example, in order to write a query that retrieves a _Project_ using its code, it's enough to simply declare a method in our _ProjectRepository_ interface:

```
Optional<Project> findByCodeEquals(String code);
```

As we can see, we don’t have to implement this method, we just have to declare it in the interface. **At runtime, the framework will derive the underlying query by parsing the method name and returning an Optional object.**

Let’s invoke this method from our main class:

```
Optional<Project> project1 = projectRepository.findByCodeEquals("P1"); LOG.info("Project with code P1: \n{}", project1);
```

In order to analyze the query that Spring JPA generates, we'll enable query logging by setting the appropriate property in the _application.properties_ file:

```
spring.jpa.show-sql=true
```

Let’s run the app and observe the generated query in the log output:

```
select project0_.id as id1_0_, //..
from project project0_
where project0_.code=?

Project with code P1:
Optional[Project [id=1, code=P1, name=Project 1, //..]
```

As we can see, the query generated by Spring JPA includes a _WHERE_ clause to filter the rows based on the _code_ attribute value. As a result, the query returns the corresponding _Project_ object wrapped into an _Optional_ type.

## Structure of Derived Query Methods

The query worked because the method follows a certain method naming convention supported by the framework. In this section, we’ll discuss the convention in order to get a better understanding of how it works.

First of all, **the method names should follow a camel-case convention,** so that the framework can parse and split the method name correctly.

**The method name consists of a "subject" and a "predicate" section**. The first part, _find_…_By,_ defines the subject of the query, while the second part, _CodeEquals,_ forms the predicate.

### Subject

**The subject part of the query primarily denotes the intent of the query.** For example, _find_…_By_ is a subject keyword that roughly translates to a select query.

Spring JPA supports multiple subject-introducing keywords. For instance, we can get the count of records in the query result by using the _count_…_By_ keyword:

```
int countByName(String name)
```

As the name implies, this method returns an integer value denoting the count of projects whose name field equals the one passed as the function argument. Let's invoke this method, and log its result:

```
int projectCount = projectRepository.countByName("Project 1");
LOG.info("Number of projects with name 'Project 1':\n{}", projectCount);
```
Now we can run the application and find the corresponding query generated by Spring JPA in the console output, together with the expected message:

```
select count(project0_.id) as col_0_0_  from project project0_  where project0_.name=?

Number of projects with name 'Project 1':
1
```

Notice that our query method is translated to a _COUNT_ clause. As expected, the query returns an integer value of 1.

Among other subject keywords supported by Spring, we should mention the following ones:

-   _exists..By_
-   _delete..By_
-   _query..By_

For the complete list of supported keywords, you can check the reference in the Resources section.

Finally, it’s worth mentioning that **the subject can include some result-limiting keywords, as well as some descriptive text**. For example, let’s look at the following query methods:

```
int countDistinctByName(String name);
int countBaeldungProjectsByName(String name);
```

In the first method, we added the _DISTINCT_ result-limiting keyword, which affects the generated query.

In contrast, we added just descriptive text to the second method; 'BaeldungProjects' will simply be ignored by the framework, as its role is just to provide additional information about the query intent.

### Predicate

Anything after the first _By_ keyword is interpreted as the predicate, and **it defines the criteria of the query, containing the entity-specific conditional expressions.**

We can use various condition keywords, such as _Equals_, _Containing,_ _GreaterThan_, along with the entity’s property names to express the conditions.

For example, in the query we defined previously, we used the _Equals_ condition applied to the _code_ attribute of the Project:

```
Optional<Project> findByCodeEquals(String code);
```

Spring JPA supports many query keywords, which enhances the querying capability using derived query methods. We'll explore these more in a future lesson.

## Resources
- [Spring Data derived queries](https://www.baeldung.com/spring-data-derived-queries)
- [Spring JPA Repositories query creation](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation)
- [Spring Data query methods](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods)
- [Spring Data Supported keywords](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-keywords)
